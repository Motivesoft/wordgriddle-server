<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <title>wordgriddle</title>
</head>

<body>
    <!-- Top-level elements of the display -->
    <div class="panel">
        <h1>wordgriddle</h1>
    </div>
    <div class="panel" id="puzzleName"></div>
    <div class="grid-container" id="letterGrid"></div>
    <div class="panel" id="notes">Swipe to select words</div>

    <h3>Other Puzzles</h3>
    <table id="puzzleTable">
        <thead>
            <tr>
                <th>Name</th>
                <th>Difficulty</th>
                <th>Category</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody id="puzzleList"></tbody>
    </table>

    <!-- Used to display lines etc. over the grid -->
    <svg id="trail" width="100%" height="100%"></svg>

    <!--
      This 'notes' panel can be used to display information for debugging purposes, e.g.:

        const notes = document.getElementById('notes');
        notes.innerHTML = `Messages and ${values}`;
    -->

    <script>
        // Singleton class instance that puzzles are loaded into
        var letterGrid;
        
        function openDailyPuzzle() {
            fetch(`/api/dailypuzzle`)
                .then(response => response.json())
                .then(data => {
                    console.log(`Retrieve daily puzzle: ${data.id}`);
                    openPuzzle(data.id);
                })
                .catch(error => console.error('Error:', error));
        }

        function openPuzzle(id) {
            fetch(`/api/puzzle/${id}`)
                .then(response => response.json())
                .then(data => {
                    console.log(`Retrieve game data: ${data.letters}`);

                    const puzzleName = document.getElementById('puzzleName');
                    puzzleName.innerHTML = `<strong>${data.name}</strong> (created by ${data.author})</br>${data.difficulty}`;

                    letterGrid.open(Array.from(data.letters), data.words, data.bonusWords, data.excludedWords);
                })
                .catch(error => console.error('Error:', error));
        }

        class LetterGrid {
            constructor() {
                this.grid = document.getElementById('letterGrid');
                this.trail = document.getElementById('trail');

                this.attachEventListeners();
            }

            open(letters, words, bonusWords, excludedWords) {
                // Store the word lists
                this.letters = letters;
                this.words = words;
                this.bonusWords = bonusWords;
                this.excludedWords = excludedWords;

                // Clear state
                this.foundWords = [];
                this.foundBonusWords = [];
                this.isDrawing = false;
                this.selectedLetters = [];
                this.lastCell = null;

                // Grids are square by design and so the length of each size is the square root of the number of letters
                this.gridSize = Math.sqrt(letters.length);
                this.grid.style.gridTemplateColumns = `repeat(${this.gridSize}, 80px)`;
                this.grid.style.gridTemplateRows = `repeat(${this.gridSize}, 80px)`;

                // Only register mouse moves/touches within 'tolerance' pixels of the centre of a grid item
                this.tolerance = 30;

                this.initializeGrid();
            }

            initializeGrid() {
                this.grid.innerHTML = '';
                this.letters.forEach((letter, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-item';
                    cell.textContent = letter;
                    cell.dataset.letter = letter;
                    cell.dataset.index = index;

                    // Style the unusable parts of the grid so they look and interact as we need them to
                    if (letter === ' ') {
                        cell.classList.add('hidden');
                    }

                    // Add the cell to the grid
                    this.grid.appendChild(cell);
                });

                const notes = document.getElementById('notes');
                notes.innerHTML = "Swipe to select words";
            }

            attachEventListeners() {
                this.grid.addEventListener('mousedown', this.handleMouseStart.bind(this));
                this.grid.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseEnd.bind(this));

                this.grid.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.grid.addEventListener('touchmove', this.handleTouchMove.bind(this));
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            // Mouse handlers

            handleMouseStart(e) {
                this.startDrawing(e);
            }

            handleMouseMove(e) {
                // Extract the mouse target and process it
                // Pass in the individual elements rather than the event as 'draw()'
                // needs to service mouse and touch events and has a signature to suit
                this.draw(e.target, e.clientX, e.clientY);
            }

            handleMouseEnd(e) {
                this.stopDrawing();
            }

            // Touch handlers

            handleTouchStart(e) {
                e.preventDefault();

                this.startDrawing(e);
            }

            handleTouchMove(e) {
                e.preventDefault();

                // Work out where we have dragged to and process it
                const touch = e.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);

                if (element) {
                    this.draw(element, touch.clientX, touch.clientY);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();

                this.stopDrawing();
            }

            // Dragging and drawing methods

            // Start a new drag operation
            startDrawing(e) {
                // React to a click or touch, unless on a 'hidden' square
                if (e.target.classList.contains('grid-item') && !e.target.classList.contains('hidden')) {
                    this.isDrawing = true;
                    this.selectedLetters = [{
                        letter: e.target.dataset.letter,
                        index: parseInt(e.target.dataset.index)
                    }];
                    e.target.classList.add('selected');

                    this.drawBlob(e.target);

                    this.lastCell = e.target;
                }
            }

            // Continue a drag operation
            // This takes a target HTML element and mouse/touch x,y coordinates 
            draw(cell, clientX, clientY) {
                // Drop out if we're not currently in a drag operation
                if (!this.isDrawing) {
                    return;
                }

                // If we're on a cell in the grid and have moved from the previous cell, treat this as a drag gesture
                // unless the cell contains a space, intended to mean a gap in the layout that the user may not select
                if (cell.classList.contains('grid-item') && cell !== this.lastCell && cell.dataset.letter !== ' ') {
                    // Reject points too close to the edge sto avoid false positives
                    const cellRect = cell.getBoundingClientRect();
                    const cellCentreX = cellRect.left + (cellRect.width / 2);
                    const cellCentreY = cellRect.top + (cellRect.height / 2);
                    if (Math.abs(cellCentreX - clientX) > this.tolerance || Math.abs(cellCentreY - clientY) > this.tolerance) {
                        return;
                    }

                    // Where are we?
                    const cellIndex = parseInt(cell.dataset.index);
                    const cellCol = cellIndex % this.gridSize;
                    const cellRow = (cellIndex - cellCol) / this.gridSize;

                    // Where have we come from?
                    const prevIndex = this.selectedLetters[this.selectedLetters.length - 1].index;
                    const prevCol = prevIndex % this.gridSize;
                    const prevRow = (prevIndex - prevCol) / this.gridSize;

                    // What will help us work out if this is a valid move - valid being -1 and 1 respectively
                    const lastSelectedIndex = this.selectedLetters.findIndex(item => item.index === cellIndex);
                    const distance = Math.max(Math.abs(cellCol - prevCol), Math.abs(cellRow - prevRow));

                    // lastSelectedIndex = -1 iff cell is not part of the current selection
                    // distance = 1 if the origin and new cell are adjacent

                    // if a valid move, select the square
                    if (lastSelectedIndex === -1 && distance === 1) {
                        // Add new cell to selection
                        cell.classList.add('selected');
                        this.selectedLetters.push({
                            letter: cell.dataset.letter,
                            index: cellIndex
                        });
                        this.drawLine(this.lastCell, cell);

                        this.lastCell = cell;
                    } else if (lastSelectedIndex !== -1) {
                        // Encountered an already selected cell. Is this a step backwards
                        if (cellIndex === this.selectedLetters[this.selectedLetters.length - 2]?.index) {
                            // Pop the last selected letter and deselect its cell

                            const prevIndex = this.selectedLetters[this.selectedLetters.length - 1].index;
                            const prevCell = this.grid.childNodes[prevIndex];
                            prevCell.classList.remove('selected');

                            this.trail.removeChild(this.trail.lastChild);
                            this.selectedLetters.pop();

                            this.lastCell = cell;
                        }
                    }

                    const notes = document.getElementById('notes');
                    const entry = this.selectedLetters.map(item => item.letter).join('');
                    notes.innerHTML = `${entry}`;
                }
            }

            // Stop a drag operation and process the outcome
            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;

                    const word = this.selectedLetters.map(item => item.letter).join('').toLowerCase();
                    const notes = document.getElementById('notes');
                    if (word.length > 3) {
                        console.log('Selected letters:', word);
                        
                        if (this.excludedWords.includes(word)) {
                            notes.innerHTML = `Excluded word`;
                        } else if (this.bonusWords.includes(word)) {
                            if (this.foundBonusWords.includes(word)) {
                                notes.innerHTML = `Already found bonus word: ${word}`;
                            } else {
                                notes.innerHTML = `Bonus word: ${word}`;
                                this.foundBonusWords.push(word);
                            }
                        } else if (this.words.includes(word)) {
                            if (this.foundWords.includes(word)) {
                                notes.innerHTML = `Already found word: ${word}`;
                            } else {
                                notes.innerHTML = `Found word: ${word}`;
                                this.foundWords.push(word);
                                
                                if (this.words.length === this.foundWords.length) {
                                    // TODO announce and process game over
                                    console.log("Finished!!");
                                }
                            }
                        } else {
                            notes.innerHTML = `Not in list`;
                        }
                    } else {
                        notes.innerHTML = `Word too short`;
                    }

                    // Keep progress in view
                    notes.innerHTML += `<br/>Words: ${this.foundWords.length}/${this.words.length} (Bonus: ${this.foundBonusWords.length}/${this.bonusWords.length})`;

                    // Tidy the display
                    this.clearTrail();
                    document.querySelectorAll('.grid-item')
                        .forEach(item => item.classList.remove('selected'));
                }
            }

            // Draw a line, using SVG, between two grid items (cells), from centre to centre
            drawLine(from, to) {
                // Draw a line, using SVG, between the centre of 'from' to the centre of 'to'
                // As we're using SVG here, we'll need to convert the coordinates to accomodate
                // different browsers' handling of this  
                const fromRect = from.getBoundingClientRect();
                const fromCenter = this.htmlToSvg({
                    x: fromRect.left + fromRect.width / 2,
                    y: fromRect.top + fromRect.height / 2
                });
                const toRect = to.getBoundingClientRect();
                const toCenter = this.htmlToSvg({
                    x: toRect.left + toRect.width / 2,
                    y: toRect.top + toRect.height / 2
                });

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromCenter.x);
                line.setAttribute('y1', fromCenter.y);
                line.setAttribute('x2', toCenter.x);
                line.setAttribute('y2', toCenter.y);
                line.setAttribute('stroke', 'rgba(111, 176, 92, 0.4)');
                line.setAttribute('stroke-width', '15');
                this.trail.appendChild(line);
            }

            drawBlob(cell) {
                // Draw a line, using SVG, between the centre of 'from' to the centre of 'to'
                // As we're using SVG here, we'll need to convert the coordinates to accomodate
                // different browsers' handling of this  
                const cellRect = cell.getBoundingClientRect();
                const cellCenter = this.htmlToSvg({
                    x: cellRect.left + cellRect.width / 2,
                    y: cellRect.top + cellRect.height / 2
                });

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', 24);
                circle.setAttribute('cx', cellCenter.x);
                circle.setAttribute('cy', cellCenter.y);
                circle.setAttribute('fill', 'rgba(111, 176, 92, 0.4)');
                this.trail.appendChild(circle);
            }

            // Done with the current drag, clean up the SVG trails
            clearTrail() {
                while (this.trail.firstChild) {
                    this.trail.removeChild(this.trail.firstChild);
                }
            }

            // Accept a point in the HTML DOM's coordinate space and return the equivalent in SVG space
            // Most browsers seem to offer a 1:1 relationship between the two, but Safari does not (at time of writing)
            // This method should work regardless of whether or not Safari ever changes its way of working
            htmlToSvg(point) {
                const svg = this.trail;
                const pt = svg.createSVGPoint();
                pt.x = point.x;
                pt.y = point.y;
                return pt.matrixTransform(svg.getScreenCTM().inverse());
            }

            // Accept a point in SVG coordinate space and return the equivalent in the HTML DOM's space
            // Most browsers seem to offer a 1:1 relationship between the two, but Safari does not (at time of writing)
            // This method should work regardless of whether or not Safari ever changes its way of working
            svgToHtml(point) {
                const svg = this.trail;
                const pt = svg.createSVGPoint();
                pt.x = point.x;
                pt.y = point.y;
                return pt.matrixTransform(svg.getScreenCTM());
            }
        }

        // Initialize the grid when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            letterGrid = new LetterGrid();

            // Default behaviour
            openDailyPuzzle();

            // Other puzzles - get by category, or all
            //const category = '2'; // Daily
            //const apiUrl = `/api/puzzles/${category}`;
            const apiUrl = `/api/allpuzzles`;

            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    const puzzleList = document.getElementById('puzzleList');
                    data.forEach(puzzle => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                    <td>${puzzle.name}</td>
                    <td>${puzzle.difficulty}</td>
                    <td>${puzzle.category}</td>
                    <td><button ontouchstart="openPuzzle(${puzzle.id})" onclick="openPuzzle(${puzzle.id})">Open</button></td>
                `;
                        puzzleList.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error fetching puzzles:', error);
                });
        });
    </script>
</body>

</html>